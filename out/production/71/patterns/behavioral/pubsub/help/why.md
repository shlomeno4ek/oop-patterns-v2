##Шаги реализации

- #####Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро станет издателем. Зависимые части станут подписчиками.

- #####Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.

- #####Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать только с общим интерфейсом подписчиков.

- #####Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.

  ######Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.

- #####Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.

- #####Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель мог бы отправлять какие-то данные, связанные с происшедшим событием.

  ######Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.

- #####Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

##Преимущества 
- #####Издатели не зависят от конкретных классов подписчиков и наоборот.
- #####Вы можете подписывать и отписывать получателей на лету.
- #####Реализует принцип открытости/закрытости.
##Недостаток
- #####Подписчики оповещаются в случайном порядке.