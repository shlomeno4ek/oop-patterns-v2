##Шаги реализации(простая схема)

- #####Убедитесь, что в вашей задаче есть один основной компонент и какая-то надстройка над ним.

- #####Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнения.

- #####Создайте класс конкретного компонента и поместите в него основную бизнес-логику.

- #####Создайте класс декоратора(обертки с дополнениями для базового класса).

- #####Унаследуйте компонент и декоратор от одного интерфейса. В декораторе должно быть поле типа этого интерфейса

- #####Все методы декоратора внутри себя должны вызывать логику методов основного компонента


##Шаги реализации(усложненная схема)

- #####Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.

- #####Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.

- #####Создайте класс конкретного компонента и поместите в него основную бизнес-логику.

- #####Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.

- #####И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.

- #####Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.

- #####Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

##Преимущества 

- #####Большая гибкость, чем у наследования.

- #####Позволяет добавлять обязанности на лету.

- #####Можно добавлять несколько новых обязанностей сразу.

- #####Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

##Недостатки

- #####Трудно конфигурировать многократно обёрнутые объекты.

- #####Обилие крошечных классов.